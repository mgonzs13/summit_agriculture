planner_server:
  ros__parameters:
    planner_plugins: [GridBased]
    use_sim_time: True

    GridBased:
      plugin: nav2_smac_planner/SmacPlannerLattice
      allow_unknown: True # Allow traveling in unknown space
      tolerance: 0.5 # dist-to-goal heuristic cost (distance) for valid tolerance endpoints if exact goal cannot be found.
      max_iterations: -1 # Maximum total iterations to search for before failing (in case unreachable), set to -1 to disable
      max_on_approach_iterations: 1000 # Maximum number of iterations after within tolerances to continue to try to find exact solution
      max_planning_time: 10.0 # Max time in s for planner to plan, smooth
      analytic_expansion_ratio: 3.5 # The ratio to attempt analytic expansions during search for final approach.
      analytic_expansion_max_length: 3.0 # For Hybrid/Lattice nodes: The maximum length of the analytic expansion to be considered valid to prevent unsafe shortcutting
      reverse_penalty: 2.0 # Penalty to apply if motion is reversing, must be => 1
      change_penalty: 0.05 # Penalty to apply if motion is changing directions (L to R), must be >= 0
      non_straight_penalty: 1.05 # Penalty to apply if motion is non-straight, must be => 1
      cost_penalty: 2.0 # Penalty to apply to higher cost areas when adding into the obstacle map dynamic programming distance expansion heuristic. This drives the robot more towards the center of passages. A value between 1.3 - 3.5 is reasonable.
      rotation_penalty: 5.0 # Penalty to apply to in-place rotations, if minimum control set contains them
      retrospective_penalty: 0.015
      # lattice_filepath: "" # The filepath to the state lattice graph
      lookup_table_size: 20.0 # Size of the dubin/reeds-sheep distance window to cache, in meters.
      cache_obstacle_heuristic: False # Cache the obstacle map dynamic programming distance expansion heuristic between subsiquent replannings of the same goal location. Dramatically speeds up replanning performance (40x) if costmap is largely static.
      allow_reverse_expansion: False # If true, allows the robot to use the primitives to expand in the mirrored opposite direction of the current robot's orientation (to reverse).

